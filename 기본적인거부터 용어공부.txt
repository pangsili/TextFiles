Java의 특징!

java의 철학 중1 : 같은 프로그램이 여러 운영체제에서 실행될 수 있어야 한다.

	= 윈도우에서 잘 동작하는 프로그램이 리눅스 환경에서는 잘 동작하지 않는 이런 경우를 줄인다.

	= 이식성이 높게 만들어져 있기 때문이다.

이렇게 운영체제의 종속성에서 벗어날 수 있도록 해주는 것이 Java의 핵심 구성요소 

JVM(Java Virtual Machine) 이다.


1. Java는 어떤 운영체제에서든지 프로그램이 동일하게 동작 할 수 있도록 하기 위해서 운영체제 위에

Java 소스가 들어갈 수 있는 "가상 환경" 을 두는 것을 선택했다. 그 가상 환경이 바로 JVM 이다.

"자바 컴파일러" 는 우리가 작성한 코드를 특수한 "바이트 코드" 로 변환한다.

이렇게 변환된 바이트 코드가 JVM 위에서 다시 해석되어 우리가 작성한 프로그램이 실행되는 것이다.

프로그램은 운영체제 위에서 실행되는 것이 일반적이지만, Java 는 운영체제와 프로그램 사이에

Java 만을 위한 환경 JVM 을 새롭게 구성해서 프로그램의 운영체제 종속성에서 벗어난 것이다.


2. Java 언어의 특징

- 객체 지향 언어

Java는 OOP(Object Oriented Programming) : 객체 지향 프로그래밍을 위한 언어이다.

객체 지향 프로그래밍이란?

상태와 행위를 가진 객체를 만들고, 그 객체들 간의 연결을 통해서 전체 프로그램을 만드는 프로그래밍 방법.

	= 부품들을 먼저 만들고, 그 부붐들을 조립하여 완성품을 만드는 방식과 유사하다.

- 가비지 컬렉터(Garbage Collector)

Java 는 가비지 컬렉터를 가지고 있다.

가비지 컬렉터는 사용하지 않는 메모리를 자동적으로 관리해주는 기능을 한다.

프로그램이 동작하고 시간이 지나면서 사용하지 않는 것들이 메모리를 차지하게 되는데,

메모리가 부족한 상황이 발생한다면, 자동적으로 가비지들을 정리하여 메모리를 확보해주는 기능을 한다.

- 멀티스레드(Multi-Thread)

스레드란 : 프로그램의 동작 주체(동작을 실제 수행하는 자) 라고 할 수 있습니다.

멀티스레드란 이러한 동작의 주체가 여러 개 있다는 것입니다.

한 프로그램 내에서 동작을 수행 할 수 있는 주체가 여러 개 있다면?

	동시에 여러가지 작업(동작)을 수행 할 수 있게 된다.

	그렇기에 대용량 작업의 빠른 처리가 필요한 경우에 많이 사용된다.


OOP(Object Oriented Programming) : 객체 지향 프로그래밍

객체 지향 프로그래밍은 프로그램을 만드는 여러 가지 방법론 중 하나이다.

어떠한 프로그램을 만드는 데에 있어서, 그 프로그램을 구성하는 여러 요소(객체) 들을 정의하고 구현한다.

그렇게 만들어진 요소(객체)들의 조합을 통해서최종적인 프로그래을 만드는 방식이다.

ex) 두 개의 수를 입력받아 두 수의 합을 출력하는 프로그램을 만든다고 가정

	객체 지향 프로그래밍으로 위 프로그램의 만든다면 

	숫자를 입력받는 객체를 정의 > 합을 구하는 처리를 하는 객체를 정의 > 숫자를 출력하는 객체를 정의

		> 각 객체간의 관계를 정의

이처럼 어떤 행위를 하는 주체(객체)를 정의하는 방식으로 프로그래밍을 하는 방식이다.

여기서 객체란 : 상태와 행위를 가지는 요소로 정의하는데, 

위 프로그램에서 숫자를 입력받는 객체는 숫자를 입력받는 행위와 그 숫자를 상태로 가지는 요소이다.


객체 지향 프로그래밍의 장점

1. 자연적인 모델링

객체 지향 프로그래밍은 사람들이 생각하는 방식을 그대로 프로그램에 반영하는 것이다.

예를 들면, 의자를 만드려면 쿠션, 나사, 받침대 등이 필요하고, 나사는 조여주는 역할,

쿠션은 푹신하다는 속성 등을 가지고 있고, 이것들이 잘 조합되면 의자가 나올 것이다.

이러한 일반적인 생각들을 그대로 프로그래밍하기 때문에 훨씬 자연스러운 사고방식으로 코딩을 할 수 있다.

2. 코드의 재사용성

각각의 객체들이 독립적으로 구현되어 있기 때문에, 만약 다른 프로젝트에서 동일한 행위가 필요하다면,

기존에 사용했던 객체를 그대로 가져다가 사용할 수 있다.

3. 유지보수의 용이성

객체마다 독립적이기 때문에, 문제가 생겼을 때 처음부터 하나하나 순차적으로 알아볼 필요가 없다.

문제가 생기면 해당 객체만 확인해보면 될 일이다.

또한 기능의 추가, 수정도 용이한데, 새로운 객체를 추가하거나 수정하는 것이 주변 소스에 미치는 영향이

굉장히 적기 때문이다.

4. 생산성 향상

위의 3개 종합하면 생상성이 향상된다.


Package

Java에서 패키지란 클래스의 꾸러미를 의미한다. = 클래스들이 모여있는 곳

소스를 깔끔하게 관리하기 위해서 관련 있는 소스들끼리 모아놓는 공간이다.

패키지를 사용하는 가장 큰 이유는 "클래스의 고유성 확보" 이다.

패키지는 자신에게 포함되어 있는 클래스에 고유성을 부여하게 된다.

Java 언어를 사용해서 객체 지향 프로그래밍을 하게 되면 여러 객체(클래스)들을 조합하여 프로그램을 구성한다.

그런데 이때, 안에 소스 내용은 다르지만 동일한 이름을 가진 객체(클래스)가 여러 개 있을 수 있다.

이런 것을 어느 패키지 안에 포함되어 있느냐로 구분을 할 수 있다.


Class

객체는 상태와 행동을 가지고 있다.

클래스는 만들고자 하는 객체의 상태와 행동을 정의해 놓은 틀 이다.

	이 틀을 가지고 객체를 만드는 것이다.

예) 붕어빵을 만들기 위해서는 붕어빵 틀이 필요하다.

	붕어빵 틀이 바로 클래스 -- 이 틀로 만들어진 붕어빵은 객체가 된다.

	붕어빵 틀에 팥을 넣으면 팥 붕어빵, 슈크림을 넣으면 슈크림 붕어빵이 되는데 이때,

	붕어빵 틀에는 변화가 없다. = 서로 다른 붕어빵을 만들기 위해서 새로운 붕어빵 틀이 필요하진 않다.

	마찬가지로 하나의 클래스를 이용해서 여러 속성을 가지는 객체를 만들 수 있다.

public class Person(){
	String name = "고슴도치";

	public void printName(){
		System.out.println(name);
	}
}

name 변수를 사용해서 사람의 이름(상태)를 표현했고, 

printName()이라는 메서드(함수)를 작성해서 이름을 출력하는 행위를 표현하였다.

main() 메서드에 단순히 Person person = new Person(); 객체생성한다고 사용할 수 있는 것이 아니다.

Person이라는 클래스가 어느위치에 있는, 어떤 역할을 하는 녀석인지 알아야 할 필요가 있다.

그 Person 이라는 객체가 무엇인지 명시해주는 기능이 import 이다.

import 패키지.Class명 해줌으로써 Person이라는 객체가 정확히 무엇인지를 알려 줄 수 있다. 

위의 붕어빵 얘기처럼, 하나의 클래스를 가지고 여러 속성을 가진 객체를 생성할 수 있어야 한다.

객체를 생성할 때 객체의 속성값을 직접 넣어줄 수 있도록 하는 것이 "생성자(Constructor)" 이다.

생성자는 클래스를 통해서 객체를 생성할 때 반드시 호출되며, 가장 먼저 실행되는 일종의 메서드이다.

생성자는 클래스를 구성하면서 따로 구현하지 않더라고 기본적으로 생성되기 때문에, 

이전의 Person 클래스를 통해서 객체를 만들 수 있던 것이다.

하지만 기본적으로 구현되는 생성자로는 다양한 속성 값을 가지는 객체는 생성할 수 없다.

public class Person(){
	String name = "고슴도치";

	public Person(String name){
		this.name = name;
	}
	// 이름을 설정하는 생성자
	// this는 객체 자기 자신을 가리키는 표현이다.	
	// Class 이름과 반드시 동일해야 한다.

	public void printName(){
		System.out.println(name);
	}
}

위 처럼 하면 생성자를 기본형이 아니라 내가 원하는 생성자 모양으로 바꾸었기 때문에, 

main 메서드 등에서 Person person = new Person(); 과 같은 기본형 생성자를 사용할 수 없게된다.

하지만 생성자는 여러 개 생성할 수 있기 때문에,

public class Person(){
	String name = "고슴도치";

	public Person(){

	}

	public Person(String name){
		this.name = name;
	}
	
	public void printName(){
		System.out.println(name);
	}
}

위 처럼 기본형 생성자도 다시 선언해주어서 Person person = new Person(); 도 사용이 가능해지게 된다.

생성자의 내부에 어떠한 내용도 작성하지 않으면, 그게 기본 생성자가 된다.

생성자의 역할은 "객체 속성 값의 초기화" 이다.

위의 이름을 위한 생성자는 name 속성 값을 원하는 값을로 초기화시키는 역할을 하는 것이다.

초기에 설정한 값 이외에 다른 값으로의 초기화가 필요하지 않을 경우도 있기 때문에,

초기 설정값 그대로 객체를 생성해주는 기본 생성자를 구현해 놓는 것이 좋은 코딩 습관!

public class Main{
	public static void main(String[] args){
		// Person에 기본생성자와 이름 생성자 2개가 생성되었기 때문에
		Person person = new Person();
		person person1 = new Person("코딩들개");
		// 와 같이 객체를 여러가지 생성할 수 있다.
		
		person.printName();
		person1.printName();
		// 두 가지 객체의 메서드도 모두 불러올 수 있다.
	}
}

생성자는 여러 개 생성할 수 있지만, 각각의 생성자는 유일해야 한다.

동일한 생성자를 두 개 만들 필요도 없을뿐더러, 만약 두 개가 있다면 어떤 생성자를 사용해야 하는지,

알 수 가 없을 것이다.


main 메서드
java application의 시작 이곳에서 시작인 것으로 java와의 약속이 이루어져 있다

java는 application이 실행되면 제일 먼저 main 메서드를 실행한다. void main(String[] args)

public은 접근제어자로 접근제어자는 외부에서 접근할 수 있는 일종의 제약이다.

- public : 접근에 제한이 없음

- protected : 동일한 패키지 내에 있거나, 파생 클래스의 경우 접근 가능

- default : 아무런 접근제어자를 명시하지 않았을 경우 할당하는 제어자이며, 

		동일한 패키지 내에서만 접근 가능

- private : 자기 자신의 클래스 내에서만 접근 가능

public은 어느곳에서는 해당 객체를 참조할 수 있다는 의미이다.
	
main메서드가 어디에 있든지 JVM(Java Virtual Machine)이 접근하는데 제한이 없어야 하기 때문에 

public을 접근 제어자로 붙여주는 것입니다.

static이란 단어는 java에서 "메모리에 고정이 된다, 변하지 않는다."라는 의미에서 사용됩니다.

하지만 실제로 이 static은 "공유"라는 의미를 가지고 있습니다.

	= static이 붙어 있다면, 모든 객체가 공유하는 변수, 메서드를 의미한다.

모든 객체가 공유하는(모든 객체에서 동일하게 동작하는)메서드를 사용하기 위해서 

다른 클래스에서 객체를 생성할 필요는 없게 됩니다.

그 이유는, main 메서드는 가장 먼저 실행되어야 하는 것인데 static이 없다면 

다른 클래스 혹은 다른 객체가 메인 메서드를 호출해주어야 하는데

이건 가장 먼저 실행된다는 얘기가 모순되기 때문에 그런 것이다.

그래서 static을 붙여줌으로써 어떠한 객체가 main 메서드를 호출해주지 않아도 

프로그램이 시작되면 자동적으로 메모리에 할당되고, 가장 먼저 실행될 수 있도록 하는 것이다.
		
void는 int, String, float 처럼 return값이 어떠한 형태인지 지정해주는 역할인데,

void는 반환할 값이 없는 경우에 사용한다. 단지 메서드가 실행이 끝나면 반환없이 종료만 될 때 사용.
		
String[] args 부분은 매개변수 부분으로, main 메서드를 실행하는 데 필요한 값들이 있다면,

args 변수를 통해서 main 메서드에 전달되는 것이다. args는 단수히 변수명일 뿐이다.


접근제어자

접근제어자는 변수, 함수, 클래스 등을 선언할 때 사용된다.

말 그대로 해당 변수나 함수 등에 대한 사용자의 접근을 제한하는 역할을 한다.

접근 제한을 통해서 해당 정보를 외부로부터 보호하는 것이다.

- public : 접근에 제한이 없음

- protected : 동일한 패키지 내에 있거나, 파생 클래스의 경우 접근 가능

- default : 아무런 접근제어자를 명시하지 않았을 경우 할당하는 제어자이며, 

		동일한 패키지 내에서만 접근 가능

- private : 자기 자신의 클래스 내에서만 접근 가능

private -> default -> protected -> public 순으로 보다 많은 접근을 허용합니다.

protected와 default의 차이 = protected 변수는 파생 클래스에서도 접근이 가능하다는 것이다.

이것을 확인해 보기 위해서는 상속(Inheritance)를 이용한 클래스의 생성이 필요하다.

클래스 선언 뒤에 "extends 상속할 클래스명"을 입력해 줌으로써 해당 클래스를 상속할 수 있다.

상속을 하게 되면 상속하는 클래스에 있는 변수나 함수를 사용할 수 있게 된다.

서로 다른 패키지에 있지만, 상속시켰다면, protected 변수는 사용이 가능하고, default는 사용이 불가능하다.

private는 외부 어디서도 접근이 불가능하다. 오직 해당 클래스 내에서만 가능하다.


★ final 변수

java 에서는 불변성을 확보 할 수 있도록 final 키워드를 제공하고 있다.

클래스나 변수에 final을 붙이면 처음 정의된 상태가 변하지 않는 것을 보장한다는 의미이다.

final String hello = "Hello world";

hello = "See you around";  // 이런게 에러가 발생한다.

클래스에 붙이게 되면 상속할 수 없게 된다.

메서드에 붙이면 오버라이드가 안된다. 


★ getter, setter

자바에서는 private 를 사용해서 멤버 변수로의 접근을 제어하는데, 

private 으로 선언된 인스턴스 필드에 접근하기 위해서 Getter, Setter 를 사용합니다.

Setter는 인스턴스 필드에 접근해서 사용하는 함수로, 매개변수로 멤버 변수를 초기화 합니다.

Getter 도 인스턴스 필드에 접근해서 사용하는 함수입니다. 초기화된 멤버 변수를 return 합니다.

멤버변수가 어떤 값으로도 초기화되지 않았다면 null을 리턴합니다.

항상 set이 먼저여야 한다?


★ 싱글톤 클래스 만들기

1. 생성자를 private 로 만든다.

2. 이 싱글톤 클래스를 반환 유형으로 한 정적 메서드를 작성한다.

일반 클래스의 경우 클래스를 정의할 때 생성자를 사용하는 반면에, 싱글톤 클래스의 경우

getInstance() 메서드를 사용한다.


★ if의 continue

반복문 내에서만 사용되며, 반복이 진행되는 도중 continue 문을 만나면 

다음 continue 다음과정은 하지 않고 바로 다시 반복문으로 돌아가서 다음 반복을 실행한다.

ex)
for(int i = 0; i <= 10; i++){

	if(i % 2 == 0){
	
		continue;
	
	}
	
	System.out.println(i);
	
}

이 경우 나머지가 0인 경우 아래의 continue가 실행되어 아래 println을 실행하지 않는다.


★ if의 break 문

이것도 위와 같이 반복문에서 사용한다.

break 문은 탈출문으로 반복문에서 탈출하는 코드이다.

ex)
for(int i = 0; i < 10; i++){

	if(i > 5){
	
		break;
	
	}
	
	printf("%d", i);

}

이러면 위 코드는 반복문 10번을 출력하게 되어있지만 결과적으로는 6번만 실행하게 된다.

0, 1, 2, 3, 4, 5

if 문의 i 가 5보다 크면 break 를 실행하게 해서 그렇다.
